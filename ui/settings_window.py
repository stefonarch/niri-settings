import sys
import subprocess
import os
import re
import webbrowser
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                             QHBoxLayout, QPushButton, QTabWidget, QStyle, QMessageBox)
from PyQt6.QtCore import Qt, QTranslator, QLocale, QLibraryInfo
from PyQt6.QtGui import QIcon

from .conf_path import get_config_path, get_niri_config_path
from .all_tabs import AppearanceTab, BehaviorTab ,TouchpadTab, MouseTab,KeyboardTab
from .keybinds_tab import KeyBindsTab
from .files_tab import FilesTab
from .tools_tab import ToolsTab

# Where are we?
current_desktop = os.environ.get('XDG_CURRENT_DESKTOP', '')
desktop_list = [item.strip() for item in current_desktop.split(':')]

class SettingsWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.config_path = get_config_path()
        self.niri_config_path = get_niri_config_path()
        self.init_ui()
        self.load_settings()

    def open_wiki(self):
        wiki_url = "https://yalter.github.io/niri/Configuration%3A-Introduction.html"
        webbrowser.open(wiki_url)

    def init_ui(self):
        self.setWindowTitle(self.tr('Niri Settings'))

        icon = QIcon.fromTheme("niri-settings",
            QIcon.fromTheme("preferences-desktop",
            self.style().standardIcon(QStyle.StandardPixmap.SP_FileDialogDetailedView)))
        if icon.isNull():
            icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileDialogDetailedView)  # Final fallback
        self.setWindowIcon(icon)

        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main layout
        main_layout = QVBoxLayout(central_widget)

        # Create tab widget
        self.tabs = QTabWidget()
        tab_bar = self.tabs.tabBar()
        tab_bar.setUsesScrollButtons(False)
        tab_bar.setExpanding(True)#does nothing

        # Create tabs
        self.appearance_tab = AppearanceTab(self)
        self.behavior_tab = BehaviorTab(self)
        self.touchpad_tab = TouchpadTab(self)
        self.mouse_tab = MouseTab(self)
        self.keyboard_tab = KeyboardTab(self)
        self.keybinds_tab = KeyBindsTab(self)
        self.files_tab = FilesTab(self)
        self.tools_tab = ToolsTab(self)

        self.tabs.addTab(self.appearance_tab, self.tr("Appearance"))
        self.tabs.addTab(self.behavior_tab, self.tr("Behavior"))
        self.tabs.addTab(self.touchpad_tab, self.tr("Touchpad"))
        self.tabs.addTab(self.mouse_tab, self.tr("Mouse"))
        self.tabs.addTab(self.keyboard_tab, self.tr("Keyboard"))
        self.tabs.addTab(self.keybinds_tab, self.tr("Shortcuts"))
        self.tabs.addTab(self.files_tab, self.tr("Files"))
        self.tabs.addTab(self.tools_tab, self.tr("Tools"))

        main_layout.addWidget(self.tabs)

        # Button layout
        button_layout = QHBoxLayout()

        wiki_btn = QPushButton(self.tr('Wiki'))
        wiki_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MessageBoxInformation))
        wiki_btn.clicked.connect(self.open_wiki)

        apply_btn = QPushButton(self.tr('Apply'))
        apply_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DialogApplyButton))
        apply_btn.clicked.connect(self.apply_settings)

        close_btn = QPushButton(self.tr('Close'))
        close_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DialogCloseButton))
        close_btn.clicked.connect(self.close)

        button_layout.addWidget(wiki_btn)
        button_layout.addStretch()
        button_layout.addWidget(apply_btn)
        button_layout.addWidget(close_btn)

        main_layout.addLayout(button_layout)

    def apply_settings(self):
        """Save settings in KDL format"""
        self.save_behavior_config()
        self.save_touchpad_config()
        self.save_mouse_config()
        self.save_keyboard_config()
        self.save_include_setting()
        print(f"Settings applied to {self.config_path}")

    def save_include_setting(self):

        if 'LXQt' in desktop_list:
            keybinds_to_add = 'include "niri/keybinds.kdl" // Added by niri-settings\n'
            include_to_add = 'include "niri/basicsettings.kdl" // Added by niri-settings\n'
        else:
            keybinds_to_add = '\ninclude "keybinds.kdl" // Added by niri-settings\n'
            include_to_add = '\ninclude "basicsettings.kdl" // Added by niri-settings\n'

        with open(self.niri_config_path, 'r', encoding='utf-8') as f:
            content = f.read()

        if include_to_add.strip() not in content:
            with open(self.niri_config_path, 'a', encoding='utf-8') as f:
                f.write(include_to_add)
                f.write(keybinds_to_add)

    def save_behavior_config(self):
        """Save behavior and appearance configuration"""
        with open(self.config_path, 'w') as f:
            f.write('// Generated by niri-settings - Edits will be overwritten!\n\n')
            if self.appearance_tab.csd_checkbox.isChecked():
                f.write('// prefer-no-csd\n\n')
            else:
                f.write('prefer-no-csd\n\n')
            f.write('overview {\n')
            f.write(f'    zoom {self.appearance_tab.overview_spinbox.value()}\n')
            f.write('}\n\nanimations {\n')
            if self.appearance_tab.animations_enable_checkbox.isChecked():
                f.write('    on\n')
            else:
                f.write('    off\n')
            f.write(f'    slowdown {self.appearance_tab.animations_spinbox.value()}\n')

            # Layout block
            f.write('}\n\nlayout {\n')
            if self.appearance_tab.shadows_checkbox.isChecked():
                f.write('    shadow {\n    on\n    }')
            else:
                f.write('    shadow {\n    off\n    }')
            f.write(f'\n\n    gaps {self.appearance_tab.gaps_spinbox.value()}\n')

            if self.behavior_tab.always_center_single_checkbox.isChecked():
                f.write(f'    always-center-single-column\n')

            if (self.behavior_tab.tabbed_radio.isChecked()):
                f.write('    default-column-display "tabbed"\n')
            else:
                f.write('    default-column-display "normal"\n')

            if (self.behavior_tab.column_proportion_radio.isChecked()):
                f.write('    default-column-width { proportion')
                f.write(f' {self.behavior_tab.column_proportion_spinbox.value()};')
                f.write('}\n')

            if (self.behavior_tab.column_width_radio.isChecked()):
                f.write('    default-column-width { fixed')
                f.write(f' {self.behavior_tab.column_width_spinbox.value()};')
                f.write('}\n')
            if (self.behavior_tab.app_decide_radio.isChecked()):
                f.write('    default-column-width { }\n')

            if (self.behavior_tab.column_never_radio.isChecked()):
                f.write('    center-focused-column "never"\n')
            if (self.behavior_tab.column_always_radio.isChecked()):
                f.write('    center-focused-column "always"\n' )
            if (self.behavior_tab.column_on_overflow_radio.isChecked()):
                f.write('    center-focused-column "on-overflow"\n')
            if self.behavior_tab.empty_workspace_above_checkbox.isChecked():
                f.write('    empty-workspace-above-first\n')
            else:
                f.write('    // empty-workspace-above-first\n')

            f.write('\n    struts {\n')
            f.write(f'        left {self.appearance_tab.struts_left_spin.value()}\n')
            f.write(f'        right {self.appearance_tab.struts_right_spin.value()}\n')
            f.write(f'        top {self.appearance_tab.struts_top_spin.value()}\n')
            f.write(f'        bottom {self.appearance_tab.struts_bottom_spin.value()}\n')

            f.write('    }\n\n    focus-ring {\n')
            if (self.appearance_tab.focus_ring_enable_checkbox.isChecked()
                and self.appearance_tab.focus_radio.isChecked()):
                f.write('        on\n')
            else:
                f.write('        off\n')
            f.write(f'        width {self.appearance_tab.focus_ring_spinbox.value()}\n')
            f.write(f'        active-color "{self.appearance_tab.current_color}"\n')
            f.write(f'        inactive-color "{self.appearance_tab.current_inactive_color}"\n')

            f.write('    }\n\n    border {\n')
            if (self.appearance_tab.focus_ring_enable_checkbox.isChecked()
                and self.appearance_tab.border_radio.isChecked()):
                f.write('        on\n')
            else:
                f.write('        off\n')
            f.write(f'        width {self.appearance_tab.focus_ring_spinbox.value()}\n')

            f.write(f'        active-color "{self.appearance_tab.current_color}"\n')
            f.write(f'        inactive-color "{self.appearance_tab.current_inactive_color}"\n')

            # Tab Indicator block inside layout block
            f.write('    }\n\n    insert-hint {\n')
            if self.appearance_tab.hint_enable_checkbox.isChecked():
                f.write('        // off\n')
            else:
                f.write('        off\n')
            f.write(f'        color "{self.appearance_tab.current_hint_color}70"\n') # opacity 70
            f.write('    }\n\n    tab-indicator {\n')
            if self.appearance_tab.hide_indicator_checkbox.isChecked():
                f.write('        hide-when-single-tab\n')
            if self.appearance_tab.place_within_checkbox.isChecked():
                f.write('        place-within-column\n')
            f.write(f'        corner-radius {self.appearance_tab.corner_radius_spinbox.value()}\n')
            f.write(f'        width {self.appearance_tab.tab_width_spinbox.value()}\n')
            f.write(f'        length total-proportion={self.appearance_tab.length_spinbox.value()}\n')
            f.write(f'        gap {self.appearance_tab.tab_gap_spinbox.value()}\n')
            f.write(f'        gaps-between-tabs {self.appearance_tab.gap_between_spinbox.value()}\n')
            f.write('    }\n}\n')

            # Window rule block for corner rounding
            f.write('\nwindow-rule {\n    geometry-corner-radius ')
            f.write(f'{self.appearance_tab.corner_rounding_spinbox.value()}\n')
            f.write('    clip-to-geometry true\n    draw-border-with-background false\n}')

            # Input block
            f.write(' \n\ninput {\n')
            if self.behavior_tab.warp_mouse_to_focus_checkbox.isChecked():
                f.write('    warp-mouse-to-focus\n')
            else:
                f.write('    // warp-mouse-to-focus\n')
            if self.behavior_tab.focus_follows_mouse_checkbox.isChecked():
                f.write('    focus-follows-mouse\n')
            else:
                f.write('    // focus-follows-mouse\n')
            if self.behavior_tab.disable_power_key_checkbox.isChecked():
                f.write('    disable-power-key-handling\n')
            else:
                f.write('    // disable-power-key-handling\n')
            if self.behavior_tab.workspace_auto_back_forth_checkbox.isChecked():
                f.write('    workspace-auto-back-and-forth\n')
            else:
                f.write('    // workspace-auto-back-and-forth\n')
            if self.behavior_tab.super_radio.isChecked():
                f.write('    mod-key "Super"\n')
            elif self.behavior_tab.alt_radio.isChecked():
                f.write('    mod-key "Alt"\n')
            elif self.behavior_tab.ctrl_radio.isChecked():
                f.write('    mod-key "Ctrl"\n')

    def save_touchpad_config(self):

        with open(self.config_path, 'a') as f:
            f.write('    \n')
            f.write('    touchpad {\n')

            if self.touchpad_tab.tap_checkbox.isChecked():
                f.write('        tap\n')
            else:
                f.write('        // tap\n')
            if self.touchpad_tab.dwt_checkbox.isChecked():
                f.write('        dwt\n')
            else:
                f.write('        // dwt\n')
            if self.touchpad_tab.dwtp_checkbox.isChecked():
                f.write('        dwtp\n')
            else:
                f.write('        // dwtp\n')
            if self.touchpad_tab.natural_scroll_checkbox.isChecked():
                f.write('        natural-scroll\n')
            else:
                f.write('        // natural-scroll\n')
            if self.touchpad_tab.drag_checkbox.isChecked():
                f.write('        drag true\n')
            else:
                f.write('        drag false\n')
            if self.touchpad_tab.drag_lock_checkbox.isChecked():
                f.write('        drag-lock\n')
            else:
                f.write('        // drag-lock\n')
            if self.touchpad_tab.disable_external_mouse_checkbox.isChecked():
                f.write('        disabled-on-external-mouse\n')
            else:
                f.write('        // disabled-on-external-mouse\n')
            if self.touchpad_tab.left_handed_checkbox.isChecked():
                f.write('        left-handed\n')
            else:
                    f.write('        // left-handed\n')

            if self.touchpad_tab.clickfinger_radio.isChecked():
                f.write('        click-method "clickfinger"\n')
            if self.touchpad_tab.btn_areas_radio.isChecked():
                f.write('        click-method "button-areas"\n')

            if self.touchpad_tab.no_scroll_radio.isChecked():
                f.write('        scroll-method "no-scroll"\n')
            elif self.touchpad_tab.two_finger_radio.isChecked():
                f.write('        scroll-method "two-finger"\n')
            elif self.touchpad_tab.edge_radio.isChecked():
                f.write('        scroll-method "edge"\n')
            elif self.touchpad_tab.button_radio.isChecked():
                f.write('        scroll-method "on-button-down"\n')

            f.write(f'        accel-speed {self.touchpad_tab.accel_speed_slider.value() / 100:.2f}\n')
            f.write(f'        accel-profile "{self.touchpad_tab.accel_profile_combobox.currentText()}"\n')
            f.write(f'        tap-button-map "{self.touchpad_tab.tap_button_map_combobox.currentText()}"\n')
            f.write(f'        scroll-factor {self.touchpad_tab.scroll_factor_spinbox.value()}\n')
            f.write('    }\n')

    def save_mouse_config(self):

        with open(self.config_path, 'a') as f:
            f.write('    \n')
            f.write('    mouse {\n')
            if self.mouse_tab.natural_scroll_checkbox.isChecked():
                f.write('        natural-scroll\n')
            else:
                f.write('        // natural-scroll\n')
            if self.mouse_tab.left_handed_checkbox.isChecked():
                f.write('        left-handed\n')
            else:
                f.write('        // left-handed\n')
            if self.mouse_tab.middle_emulation_checkbox.isChecked():
                f.write('        middle-emulation\n')
            else:
                f.write('        // middle-emulation\n')

            f.write(f'        accel-speed {self.mouse_tab.accel_speed_slider.value() / 100:.2f}\n')
            f.write(f'        accel-profile "{self.mouse_tab.accel_profile_combobox.currentText()}"\n')
            f.write(f'        scroll-factor {self.mouse_tab.scroll_factor_spinbox.value()}\n')

            f.write('    }\n')

    def save_keyboard_config(self):
        with open(self.config_path, 'a') as f:  # Append to the file
            f.write('    \n')
            f.write('    keyboard {\n')
            f.write(f'        track-layout "{self.keyboard_tab.track_layout_combobox.currentText()}"\n')
            if self.keyboard_tab.numlock_checkbox.isChecked():
                f.write('        numlock\n')
            else:
                f.write('        // numlock\n')
            lines = [
                f'           layout "{self.keyboard_tab.layout_edit.text()}"\n',
                f'           variant "{self.keyboard_tab.variant_edit.text()}"\n',
                f'           options "{self.keyboard_tab.options_edit.text()}"\n',
                f'           model "{self.keyboard_tab.model_edit.text()}"\n',
                f'           file "{self.keyboard_tab.file_edit.text()}"\n',
            ]

            # Write XKB block only if at least one line has a value
            if any('""' not in line for line in lines):
                f.write('        xkb {\n')

            layout = self.keyboard_tab.layout_edit.text()
            if layout:
                f.write(f'            layout "{layout}"\n')
            variant = self.keyboard_tab.variant_edit.text()
            if variant:
                f.write(f'            variant "{variant}"\n')
            options = self.keyboard_tab.options_edit.text()
            if options:
                f.write(f'            options "{options}"\n')
            model = self.keyboard_tab.model_edit.text()
            if model:
                f.write(f'            model "{model}"\n')
            file_ = self.keyboard_tab.file_edit.text()
            if file_:
                f.write(f'            file "{file_}"\n')
            if any('""' not in line for line in lines):
                f.write('        }\n')# End XKB block

            f.write(f'        repeat-delay {self.keyboard_tab.repeat_delay_spinbox.value()}\n')
            f.write(f'        repeat-rate {self.keyboard_tab.repeat_rate_spinbox.value()}\n')
            f.write('    }\n')
            f.write('}\n\n')

            # Behavior Tab: Hot Key Overlay
            f.write('hotkey-overlay {\n    hide-not-bound\n')
            if self.behavior_tab.hotkey_overlay_checkbox.isChecked():
                f.write('    // skip-at-startup\n')
            else:
                f.write('    skip-at-startup\n')
            f.write('    }\n\n')

            # Gestures
            f.write('gestures {\n')
            f.write('    hot-corners {\n')
            if self.behavior_tab.hot_corners_checkbox.isChecked():
                f.write('        off\n')
            else:
                f.write('        // off\n')
            f.write('    }\n}\n\n')

            # Debug
            f.write('debug {\n')
            if self.behavior_tab.focus_request_checkbox.isChecked():
                f.write('    honor-xdg-activation-with-invalid-serial \n')
            else:
                    f.write('    // honor-xdg-activation-with-invalid-serial \n')
            f.write('}\n\n')

            # Cursor
            f.write('cursor {\n')
            if self.behavior_tab.hide_while_typing_checkbox.isChecked():
                f.write('    hide-when-typing \n')
            else:
                f.write('    // hide-when-typing \n')
            if self.behavior_tab.inactive_enable_checkbox.isChecked():
                f.write(f'    hide-after-inactive-ms {self.behavior_tab.inactive_spinbox.value()}\n')
            else:
                f.write('    // hide-after-inactive-ms {self.behavior_tab.inactive_spinbox.value()}\n')

            f.write('}\n')

            # Screenshot path
            path = self.behavior_tab.screenshot_path_edit.text()
            if path:
                f.write(f'\nscreenshot-path "{path}"\n')

            # niri-settings settings
            if self.files_tab.exclude_backups_checkbox.isChecked():
                f.write('\n    // Settings of niri-settings\n    // * do not show backups\n')

    def load_settings(self):
        """Parse existing settings"""

        if not os.path.isfile(self.config_path):
            return  # nothing to parse


        try:
            with open(self.config_path, 'r') as f:
                content = f.read()
            try:
                # Parse Appearance Settings
                self.appearance_tab.csd_checkbox.setChecked(
                    '// prefer-no-csd' in content
                )
                value = re.search(r'zoom\s+([0-9]*\.?[0-9]+)', content)
                if value:
                    self.appearance_tab.overview_spinbox.setValue(float(value.group(1)))

                self.appearance_tab.animations_enable_checkbox.setChecked(
                bool(re.search(r'animations\s*\{[^}]*\bon\b[^}]*\}', content)))

                value = re.search(r'slowdown\s+([0-9]*\.?[0-9]+)', content)
                self.appearance_tab.animations_spinbox.setValue(float(value.group(1)))

                value = re.search(r"gaps\s+(-?\d+)", content)
                self.appearance_tab.gaps_spinbox.setValue(int(value.group(1)))

                value = re.search(r'left\s+(-?\d+)', content)
                self.appearance_tab.struts_left_spin.setValue(int(value.group(1)))

                value = re.search(r'right\s+(-?\d+)', content)
                self.appearance_tab.struts_right_spin.setValue(int(value.group(1)))

                value = re.search(r'top\s+(-?\d+)', content)
                self.appearance_tab.struts_top_spin.setValue(int(value.group(1)))

                value = re.search(r'bottom\s+(-?\d+)', content)
                self.appearance_tab.struts_bottom_spin.setValue(int(value.group(1)))

                focus_on = bool(re.search(r'focus-ring\s*\{[^}]*\bon\b[^}]*\}', content))
                border_on = bool(re.search(r'border\s*\{[^}]*\bon\b[^}]*\}', content))
                self.appearance_tab.focus_ring_enable_checkbox.setChecked(focus_on or border_on)

                value = re.search(r'focus-ring\s*\{[^}]*width\s+(\d+)', content)
                self.appearance_tab.focus_ring_spinbox.setValue(int(value.group(1)))
                m = re.search(r'active-color\s+"([^"]+)"', content)
                color_val = m.group(1)
                self.appearance_tab.current_color = color_val
                self.appearance_tab.update_color_button()

                m = re.search(r'inactive-color\s+"([^"]+)"', content)
                inactive_color_val = m.group(1)
                self.appearance_tab.current_inactive_color = inactive_color_val
                self.appearance_tab.update_inactive_color_button()

                match = re.search(r'focus-ring\s*\{\s*on\b', content)
                if match:
                        self.appearance_tab.focus_radio.setChecked(True)
                else:
                        self.appearance_tab.border_radio.setChecked(True)

                match = re.search(r'insert-hint\s*\{[^}]*//', content, flags=re.DOTALL)
                if match:
                        self.appearance_tab.hint_enable_checkbox.setChecked(True)
                else:
                        self.appearance_tab.hint_enable_checkbox.setChecked(False)

                m = re.search(r'insert-hint\s*\{[^}]*color\s*"(?P<col>#[0-9A-Fa-f]{6})', content,
                flags=re.DOTALL)
                color_val = m.group(1)
                self.appearance_tab.current_hint_color = color_val
                self.appearance_tab.update_hint_color_button()

                block = re.search(r'tab-indicator\s*\{([^}]*)\}', content, re.DOTALL)# FIXME to do for more blocks
                tab_indicator = block.group(1)

                self.appearance_tab.hide_indicator_checkbox.setChecked(
                    'hide-when-single-tab' in tab_indicator
                    )
                self.appearance_tab.place_within_checkbox.setChecked(
                    'place-within-column' in tab_indicator
                    )
                value = re.search(r'corner-radius\s+(\d+)', tab_indicator)
                self.appearance_tab.corner_radius_spinbox.setValue(int(value.group(1)))

                value = re.search(r'width\s+(\d+)', tab_indicator)
                self.appearance_tab.tab_width_spinbox.setValue(int(value.group(1)))

                m = re.search(r'total-proportion\s*=\s*([0-9]*\.?[0-9]+)', tab_indicator)
                value = float(m.group(1))
                self.appearance_tab.length_spinbox.setValue(value)

                value = re.search(r'gap\s+(\d+)', tab_indicator)
                self.appearance_tab.tab_gap_spinbox.setValue(int(value.group(1)))

                value = re.search(r'gaps-between-tabs\s+(\d+)', tab_indicator)
                self.appearance_tab.gap_between_spinbox.setValue(int(value.group(1)))

                match = re.search(r'position\s+"([^"]+)"', tab_indicator)
                if match:
                    position = match.group(1)
                    if position == "left":
                        self.appearance_tab.left_radio.setChecked(True)
                    elif position == "top":
                        self.appearance_tab.top_radio.setChecked(True)
                    elif position == "right":
                        self.appearance_tab.right_radio.setChecked(True)
                    elif position == "bottom":
                        self.appearance_tab.bottom_radio.setChecked(True)

            except Exception as e:
                print(f"Error parsing some appearance settings key: {e} ")
                msg= QMessageBox()
                msg.setIcon(QMessageBox.Icon.Critical)
                msg.setWindowTitle(self.tr("Configuration Parsing Error"))
                msg.setText(self.tr(f"Error reading 'Appearance Settings' in {self.config_path}"))
                msg.setInformativeText(self.tr("Applying changes will reset to defaults some values, please check this file."))
                msg.exec()

            try:
                # Parse behavior settings
                behavior_match = re.search(r'touchpad\s*\{([^}]+)\}', content)
                behavior_content = behavior_match.group(1)

                self.behavior_tab.hotkey_overlay_checkbox.setChecked(
                    '// skip-at-startup' in content
                )
                self.behavior_tab.focus_request_checkbox.setChecked(
                    '// honor-xdg-activation-with-invalid-serial ' not in content
                )
                self.behavior_tab.always_center_single_checkbox.setChecked(
                    'always-center-single-column' in content
                )

                match = re.search(r'tabbed', content)
                if match:
                        self.behavior_tab.tabbed_radio.setChecked(True)
                else:
                        self.behavior_tab.normal_radio.setChecked(True)

                self.behavior_tab.disable_power_key_checkbox.setChecked(
                    '// disable-power-key-handling' not in content
                )
                self.behavior_tab.warp_mouse_to_focus_checkbox.setChecked(
                    '// warp-mouse-to-focus' not in content
                )
                self.behavior_tab.workspace_auto_back_forth_checkbox.setChecked(
                    '// workspace-auto-back-and-forth' not in content
                )
                self.behavior_tab.empty_workspace_above_checkbox.setChecked(
                    '// empty-workspace-above-first' not in content
                )
                self.behavior_tab.focus_follows_mouse_checkbox.setChecked(
                    '// focus-follows-mouse' not in content
                )
                self.behavior_tab.hide_while_typing_checkbox.setChecked(
                    '// hide-when-typing ' not in content
                )
                self.behavior_tab.inactive_enable_checkbox.setChecked(
                    '// hide-after-inactive-ms' not in content
                )
                value = re.search(r'hide-after-inactive-ms\s+(\d+)', content)
                if value:
                    self.behavior_tab.inactive_spinbox.setValue(int(value.group(1)))

                match = re.search(r'gestures\s*\{\s*hot-corners\s*\{[^}]*//[^}]*\}\s*\}', content)
                if match:
                    self.behavior_tab.hot_corners_checkbox.setChecked(False)
                else:
                    self.behavior_tab.hot_corners_checkbox.setChecked(True)

                path = re.search(r'screenshot-path\s+"([^"]+)"', content)
                if path:
                    self.behavior_tab.screenshot_path_edit.setText(path.group(1))

                match = re.search(r"default-column-width\s*\{\s*\}", content)
                if match:
                    self.behavior_tab.app_decide_radio.setChecked(True)

                m = re.search(r"\{\s*(fixed|proportion)\s+([^;]+)\s*;", content)
                if m:
                    mode = m.group(1)          # "fixed" or "proportion"
                    value = m.group(2).strip() # value

                    if mode == "fixed":
                        self.behavior_tab.column_width_radio.setChecked(True)
                        self.behavior_tab.column_width_spinbox.setValue(int(value))

                    elif mode == "proportion":
                        self.behavior_tab.column_proportion_radio.setChecked(True)
                        self.behavior_tab.column_proportion_spinbox.setValue(float(value))

                self.behavior_tab.column_never_radio.setChecked('column "never"' in content)
                self.behavior_tab.column_always_radio.setChecked('column "always"' in content)
                self.behavior_tab.column_on_overflow_radio.setChecked('column "on-overflow"' in content)

                match = re.search(r'mod-key\s+"([^"]+)"', content)
                if match:
                    mod_key = match.group(1)
                    if mod_key == "Super":
                        self.behavior_tab.super_radio.setChecked(True)
                    elif mod_key == "Alt":
                        self.behavior_tab.alt_radio.setChecked(True)
                    elif mod_key == "Ctrl":
                        self.behavior_tab.ctrl_radio.setChecked(True)

            except Exception as e:
                print(f"Error parsing some behavior settings: {e} ")
                msg= QMessageBox()
                msg.setIcon(QMessageBox.Icon.Critical)
                msg.setWindowTitle(self.tr("Configuration Parsing Error"))
                msg.setText(self.tr(f"Error reading 'Behavior Settings' in {self.config_path}"))
                msg.setInformativeText(self.tr("Applying changes will reset to defaults some values, please check this file."))
                msg.exec()

            try:
                # Parse Touchpad block settings
                touchpad_match = re.search(r'touchpad\s*\{([^}]+)\}', content)
                touchpad_content = touchpad_match.group(1)

                self.touchpad_tab.tap_checkbox.setChecked(
                    '// tap' not in touchpad_content
                )
                self.touchpad_tab.dwt_checkbox.setChecked(
                    not re.search(r'^\s*//\s*dwt\s*$', touchpad_content, re.MULTILINE)
                )

                self.touchpad_tab.dwtp_checkbox.setChecked(
                    not re.search(r'^\s*//\s*dwtp\s*$', touchpad_content, re.MULTILINE)
                )
                self.touchpad_tab.natural_scroll_checkbox.setChecked(
                    '// natural-scroll' not in touchpad_content
                )
                self.touchpad_tab.drag_checkbox.setChecked(
                    'drag false' not in touchpad_content
                )
                self.touchpad_tab.drag_lock_checkbox.setChecked(
                    '// drag-lock' not in touchpad_content
                )
                self.touchpad_tab.disable_external_mouse_checkbox.setChecked(
                    '// disabled-on-external-mouse' not in content
                )
                self.touchpad_tab.left_handed_checkbox.setChecked(
                    '// left-handed' not in touchpad_content
                )

                speed_match = re.search(r'accel-speed\s+(-?[\d.]+)', touchpad_content)

                self.touchpad_tab.accel_speed_slider.setValue(
                int(float(speed_match.group(1)) * 100)
                )

                profile_match = re.search(r'accel-profile\s+"([^"]+)"', touchpad_content)
                if profile_match:
                    profile_value = profile_match.group(1)

                    index = self.touchpad_tab.accel_profile_combobox.findText(profile_value)
                    if index >= 0:
                        self.touchpad_tab.accel_profile_combobox.setCurrentIndex(index)

                profile_match = re.search(
                    r'tap-button-map\s+"([^"]+)"',
                    touchpad_content
                )
                if profile_match:
                    profile_value = profile_match.group(1)
                    index = self.touchpad_tab.tap_button_map_combobox.findText(profile_value)
                    if index >= 0:
                        self.touchpad_tab.tap_button_map_combobox.setCurrentIndex(index)


                scroll_match = re.search(r'scroll-factor\s+([\d.]+)', touchpad_content)
                self.touchpad_tab.scroll_factor_spinbox.setValue(float(scroll_match.group(1)))

                match = re.search(r'scroll-method\s+"([^"]+)"', touchpad_content)

                scroll_method = match.group(1)
                if scroll_method == "no-scroll":
                    self.touchpad_tab.no_scroll_radio.setChecked(True)
                elif scroll_method == "two-finger":
                    self.touchpad_tab.two_finger_radio.setChecked(True)
                elif scroll_method == "edge":
                    self.touchpad_tab.edge_radio.setChecked(True)
                elif scroll_method == "on-button-down":
                    self.touchpad_tab.button_radio.setChecked(True)

                self.touchpad_tab.clickfinger_radio.setChecked(
                    'clickfinger' in content
                )
                self.touchpad_tab.btn_areas_radio.setChecked(
                    'button-areas' in content
                )


            except Exception as e:
                print(f"Error parsing some touchpad settings: {e} ")
                msg= QMessageBox()
                msg.setIcon(QMessageBox.Icon.Critical)
                msg.setWindowTitle(self.tr("Configuration Parsing Error"))
                msg.setText(self.tr(f"Error reading 'Touchpad Settings' in {self.config_path}"))
                msg.setInformativeText(self.tr("Applying changes will reset to defaults some values, please check this file."))
                msg.exec()

            # Parse Mouse settings
            try:
                mouse_match = re.search(r'mouse\s*\{([^}]+)\}', content)
                mouse_content = mouse_match.group(1)

                self.mouse_tab.natural_scroll_checkbox.setChecked(
                    '// natural-scroll' not in mouse_content
                )
                self.mouse_tab.left_handed_checkbox.setChecked(
                    '// left-handed' not in mouse_content
                )
                self.mouse_tab.middle_emulation_checkbox.setChecked(
                    '// middle-emulation' not in mouse_content
                )
                speed_match = re.search(r'accel-speed\s+(-?[\d.]+)', mouse_content)
                self.mouse_tab.accel_speed_slider.setValue(
                int(float(speed_match.group(1)) * 100)
                )

                profile_match = re.search(r'accel-profile\s+"([^"]+)"', mouse_content)
                profile_value = profile_match.group(1)
                index = self.mouse_tab.accel_profile_combobox.findText(profile_value)
                if index >= 0:
                    self.mouse_tab.accel_profile_combobox.setCurrentIndex(index)

                # Scroll factor
                scroll_match = re.search(r'scroll-factor\s+([\d.]+)', mouse_content)
                if scroll_match:
                    self.mouse_tab.scroll_factor_spinbox.setValue(float(scroll_match.group(1)))

            except Exception as e:
                print(f"Error parsing some mouse settings: {e} ")
                msg= QMessageBox()
                msg.setIcon(QMessageBox.Icon.Critical)
                msg.setWindowTitle(self.tr("Configuration Parsing Error"))
                msg.setText(self.tr(f"Error reading 'Mouse Settings' in {self.config_path}"))
                msg.setInformativeText(self.tr("Applying changes will reset to defaults some values, please check this file."))
                msg.exec()

            # Parse Keyboard settings
            try:
                self.keyboard_tab.numlock_checkbox.setChecked(
                    'numlock' in content and '// numlock' not in content
                )

                match = re.search(r'repeat-delay\s+(\d+)', content)
                self.keyboard_tab.repeat_delay_spinbox.setValue(int(match.group(1)))

                match = re.search(r'repeat-rate\s+(\d+)', content)
                self.keyboard_tab.repeat_rate_spinbox.setValue(int(match.group(1)))

                match = re.search(r'track-layout\s+"([^"]+)"', content)
                track_layout = match.group(1)
                index = self.keyboard_tab.track_layout_combobox.findText(track_layout)
                if index >= 0:
                        self.keyboard_tab.track_layout_combobox.setCurrentIndex(index)


                xkb_match = re.search(r'xkb\s*{.*?layout\s+"([^"]+)"', content, re.DOTALL)
                if xkb_match:
                    self.keyboard_tab.layout_edit.setText(xkb_match.group(1))

                variant_match = re.search(r'xkb\s*{.*?variant\s+"([^"]+)"', content, re.DOTALL)
                if variant_match:
                    self.keyboard_tab.variant_edit.setText(variant_match.group(1))

                options_match = re.search(r'xkb\s*{.*?options\s+"([^"]+)"', content, re.DOTALL)
                if options_match:
                    self.keyboard_tab.options_edit.setText(options_match.group(1))

                model_match = re.search(r'xkb\s*{.*?model\s+"([^"]+)"', content, re.DOTALL)
                if model_match:
                    self.keyboard_tab.model_edit.setText(model_match.group(1))

                file_match = re.search(r'xkb\s*{.*?file\s+"([^"]+)"', content, re.DOTALL)
                if file_match:
                    self.keyboard_tab.file_edit.setText(file_match.group(1))

                # own settings
                self.files_tab.exclude_backups_checkbox.setChecked(
                    'do not show backups' in content
                )

            except Exception as e:
                print(f"Error parsing some keyboard settings: {e} ")
                msg= QMessageBox()
                msg.setIcon(QMessageBox.Icon.Critical)
                msg.setWindowTitle(self.tr("Configuration Parsing Error"))
                msg.setText(self.tr(f"Error reading 'Keyboard Settings' in {self.config_path}"))
                msg.setInformativeText(self.tr("Applying changes will reset to defaults some values, please check this file."))
                msg.exec()

        except FileNotFoundError:
            # If file doesn't exist, use defaults
            print(f"No existing config file found at {self.config_path}, applying default settings")

            current_desktop = os.environ.get('XDG_CURRENT_DESKTOP', '')
            desktop_list = [item.strip() for item in current_desktop.split(':')]

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Icon.Information)
            msg.setWindowTitle(self.tr("Niri Settings: Configuration not found"))
            msg.setText(self.tr(f"No existing configuration file found at {self.config_path}. \n\nA new line to include \"basicsettings.kdl\" will be added at the bottom in {self.niri_config_path} when applying changes."))
            msg.setInformativeText(self.tr("This line is needed to make this application work. \nIdentical settings before this line will be ignored after."))
            msg.exec()
            pass
        except Exception as e:
            print(f"Error loading configuration: {e}")

            # Create error message box
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Icon.Critical)
            msg.setWindowTitle(self.tr("Configuration Parsing Error"))
            msg.setText(self.tr(f"Error reading settings in {self.config_path}"))
            msg.setInformativeText(self.tr("Applying changes will reset to defaults some values, please check this file."))
            msg.exec()

